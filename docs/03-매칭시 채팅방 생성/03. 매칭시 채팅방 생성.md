### 도메인 간 결합도
매칭 시, 매칭된 사람들끼리 대화를 할 수 있도록 채팅방을 생성해야 한다.  
CoupleService 내에서 매칭 성공 시 이어어 채팅방을 생성할 수도 있고, CoupleController 단에서 ChatService 를 의존하여 만들 수도 있으나,  
Couple(매칭) 도메인에서 Chat 도메인을 의존하면 다음과 같은 단점이 생길 수 있다.

- 현 구조에서는 단일 서비스 내에서 매칭 기능과 채팅 기능을 만들고 있지만, 이후 채팅 도메인이 커지거나 사용자가 많아져 채팅 서버를 매칭 서버와 분리해야 할 상황이 생길 수 있다.
- 만약 이러한 경우에, 매칭 도메인과 채팅 도메인의 결합도가 큰 상황이라면 이를 쉽게 분리하기 어려운 상황이 생길 수 있다.
- 이런 상황에 유연하게 대처하기 위해, 초기 설계부터 매칭 도메인과 채팅 도메인의 결합도를 줄이면 이점이 있을 것 같다고 판단하였다.

---  

### 도메인 간 결합도를 줄이는 방법

채팅 도메인과 매칭 도메인간의 의존성을 줄이기 위해, `이벤트`를 사용할 수 있다.  
이때 Spring 내부에서 제공해주는 ApplicationEventPublisher 를 사용할 수도 있지만,  
이는 하나의 스프링 컨테이너 내부에서 동작하기 때문에, 위에서 가정한 대로 채팅 서버와 매칭 서버가 분리되어 실행되는 경우에는 적용하지 못한다는 단점이 있다.   
오버 엔지니어링을 피하기 위해, 채팅 서버를 분리하는 상황을 미리 고려하는 것 보다는 별도의 추가기술 없이 사용 가능한 ApplicationEventPublisher 을 사용하는 게 좋겠으나,  
해당 프로젝트는 실제 서비스를 위해 만들어진 것이 아닌 다양한 문제 상황을 가정하고 이를 해결하는 방법을 고민하는 데 있으므로,  
오버 엔지니어링은 앞으로 고려하지 않도록 한다.

따라서 서비스가 분리될 것을 가정하고 ApplicationEventPublisher 대신 다른 방법을 통해 `이벤트` 기반의 아키텍처를 구축한다.


---  

### 메세지 브로커 선택

이벤트를 발행하는 메세지 브로커로는 kafka, redis pub/sub 등을 사용할 수 있을 것 같다.  
이들간의 차이점에 대해 명확히 공부해 보지는 못했으나,  
결론적으로는 Kafka 를 사용하려 한다.

데이터의 유실 방지, 대용량 데이터 처리, 분산 처리 등을 고려해 보았을 때,  
kafka 가 가장 나은 선택지인 것 같았기 때문이다. (다른 것에 비해 무겁고 사용이 어렵다는 단점이 있을 뿐, 이 외 기능적으로는 다른 기술에 비해 단점이 없어 보였다.)  
(물론 모든 기술들을 깊게 공부해 보지는 않았기 때문에, 확실하지는 않다. 다만 우선 카프카를 사용해 보고 그 과정에서 불편한 점이 있다면 그때 다른 기술들을 다시 고민해 볼 예정이다.)

---

### 발행해야 하는 이벤트

단순히 이벤트를 발행하는 것만으로는 서비스 간 강한 결합을 해소할 수 없다.
예를 들어 매칭 이후 `채팅방을 생성해달라는 이벤트`를 발행하는 경우,
매칭에서 채팅방의 생성을 기대하는 이벤트를 발행하였기 때문에, 논리적인 의존관계가 남아있게 된다.
따라서 발행한 이벤트는 대상 도메인에게 기대하는 메세지를 담에서는 안된다.
즉 이러한 경우 `매칭 성공` 이벤트를 발행해야, 두 서비스 간 강한 결합을 해소할 수 있다.


### DB와 카프카 간 정합성 문제

매칭 완료 이후 `매칭 성공` 이벤트를 전송하는 것이 100% 성공한다고 보장할 수 없다.
즉 이벤트 발행 시에는 해당 이벤트 발행이 실패할 수도 있다는 점을 고려해야 한다.

예를 들어 매칭은 완료되어 DB 상에 업데이트 되었으나,
`매칭 완료 이벤트` 를 발행하는 과정에서 네트워크 오류 등의 이유로 실패했다고 가정해보자.

이런 경우 매칭은 완료되었음에도, 매칭 완료 이벤트가 발행되지 않아 채팅방 생성 등의 작업이 이루어지지 않을 것이다.

그럼 이를 해결하기 위해서는 어떠한 방법을 사용할 수 있을까?

처음 생각나는 방법으로는 `메세지 발행을 트랜잭션 내부에서 처리`하도록 할 수 있을 것이다.
그러나 이러한 방법은 아래 두 가지 문제를 야기한다.

- 트랜잭션 내에서 네트워크 i/o 작업이 발생하므로, 그만큼 DB 커넥션을 점유하는 시간이 길어진다.
- 이벤트 발행에는 성공하였으나, DB 커밋 과정에서 오류가 발생하여 롤백된다면, 결국 로직은 실패했음에도 이벤트 발행이 성공했다는 문제가 발생한다.

즉, 해당 방법을 사용하는 것은 문제 해결에 도움을 주지는 못 하고, 오히려 악영향만 증가한다.

**2PC(Two-Phase Commit)** 이라는 방법도 있으나, 카프카에서는 2PC 를 지원하지 않는다.
(2PC 는 성능 저하 등의 문제료 요즘에는 잘 사용되지 않는다고 한다.)

그럼 이러한 문제는 해결할 수 없는걸까?  
아니다. [[03-1. 트랜잭션 아웃박스 패턴]]를 사용하여 해결할 수 있다.  
구현에 대한 내용은 [[03-2. 트랜잭션 아웃박스 패턴을 적용한 이벤트 발행 로직 설계]] 를 확인하자.
