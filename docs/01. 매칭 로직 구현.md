
### 매치가 성사되려면
A 가 B 에게 좋아요를 보냈을 때, 아래와 같은 3가지 상황이 발생한다.
1. B 도 A 에게 좋아요를 보낸 경우
2. B 는 A 에게 싫어요를 보낸 경우
3. B 는 A 에게 아무런 요청을 보내지 않은 경우

위 상황 중 **1** 번의 경우에만 매치가 성사된다.



### 매칭 로직
좋아요를 보내고, 매치가 되는 과정은 아래의 순서를 따른다.
- A가 B에게 좋아요 요청을 보낸 경우
    - 1. 좋아요 요청을 저장한다. (sender = A, target = B)
    - 2. B가 A에게 보낸 좋아요 요청이 있는지 확인한다.
    - 3. B가 A에게 보낸 좋아요가 있는 경우, 매치 데이터를 생성한다.

이 때, 좋아요를 보낸 시점에 따라 **동시성 문제**가 발생할 수 있다.  
문제가 발생하는 상황을 살펴보자.



### 동시성 문제 발생하는 상황
(db의 isolation level 은 repeatable read 라 가정한다.)
#### Case 01. 매칭 로직의 1, 2, 3번을 같은 트랜잭션 내에서 수행

```java
// 수도코드
@Transactional
public void match(Member sender, Member target) {
	MatchRequest matchRequest = newMatchRequest(sender, target);
	matchRequestRepository.save(matchRequest);
	if (matchRequestRepository.doesNotExistTargetLike(matchRequest)) {  
		return;
	}  
	Match match = Match.create(sender, target);
	return matchRepository.save(match);
}
```

1. 00:00 - `요청 1`  - A 가 B 에게 좋아요 요청
2. 00:01 - `요청 1` `Tx 1` - MatchRequest 저장 (sender - A, target - B)
3. 00:02 - `요청 2` - B 가 A 에게 좋아요 요청
4. 00:03 - `요청 2` `Tx 2` - MatchRequest 저장 (sender - B, target - A)
5. 00:04 - `요청 1` `Tx 1` - B가 A에게 보낸 MatchRequest 조회
    - `요청 2` 의 트랜잭션이 **commit 되지 않았으므로, 보이지 않음**
        - [[01-1. 트랜잭션 테스트]]
6. 00:05 - `요청 2` `Tx 2` - A가 B에게 보낸 MatchRequest 조회
    - `요청 1` 의 트랜잭션이 commit 되지 않았으므로, 보이지 않음
7. 00:06 - `요청 1` `Tx 1` - **5**의 결과, B가 A에게 보낸 MatchRequest 가 조회되지 않았으므로 Match 생성하지 않고 종료 (`Tx 1 커밋`)
8. 00:07 - `요청 2` `Tx 2` - **6** 의 결과, A가 B에게 보낸 MatchRequest 가 조회되지 않았으므로 Match 생성하지 않고 종료 (`Tx 2 커밋`)

즉 A 와 B 가 서로 좋아요 요청을 보냈지만, Match 는 생성되지 않음


#### Case 02. 매칭 로직의 1, 2, 3번을 각각 다른 트랜잭션 내에서 수행
```java
@Transactional
public void match(Member sender, Member target) {
	MatchRequest matchRequest = newMatchRequest(sender, target);
	matchRequestRepository.save(matchRequest);
	if (matchRequestRepository.doesNotExistTargetLike(matchRequest)) {  
		return;
	}  
	Match match = Match.create(sender, target);
	return matchRepository.save(match);
}
```

1. 00:00 - `요청 1` A 가 B 에게 좋아요 요청
2. 00:01 - `요청 1` MatchRequest 저장 (sender - A, target - B)
3. 00:02 - `요청 2` B 가 A 에게 좋아요 요청
4. 00:03 - `요청 2` MatchRequest 저장 (sender - B, target - A)
5. 00:04 - `요청 1` `Tx 1` - B가 A에게 보낸 MatchRequest 조회 (조회됨)
6. 00:05 - `요청 1` `Tx 1` - 조회되었음으로, 기존에 저장된 Match 있는지 조회
    - 조회 결과 없으므로 저장 (아직 commit X)
7. 00:06 - `요청 2` `Tx 2` - 조회되었음으로, 기존에 저장된 Match 있는지 조회
    - 조회 결과 없으므로 저장 (아직 commit X)
1. 00:07 - `요청 1` `Tx 1` - 커밋
2. 00:08 - `요청 2` `Tx 2` - 커밋

→  Match 가 중복 생성



---

위 문제를 해결하기 위해, 여러 방법들을 고민해 보았다.

### 해결방법 후보 1. 이벤트 발행 후 순차 처리
매칭 로직의 1번과 2,3 번을 분리하여, 1번 완료된 이후 다른 스레드 혹은 프로세스에서 2,3번을 처리하도록 한다.
(MatchRequest 저장 후 Tx 종료 -> 이벤트 publish -> **다른 스레드** 혹은 프로세스에서 순차 처리)

이때 정상 동작을 위해서는 다른 스레드 혹은 프로세스는 **싱글 스레드**에서 순차적으로 처리해야 한다.
(싱글 스레드로 처리하지 않는 이상 기존과 같은 동시성 문제가 발생할 수 있음)

이벤트를 Publish 하는 데 사용될 수 있는 기술들을 다음과 같다.
- Redis pub/sub, rabbitMQ, Kafka


카프카를 사용한다고 가정해보자.
카프카를 어떻게 설정하느냐에 따라 데이터를 순차적으로 처리할수도, 그렇지 않을수도 있다.
- 순차적으로 처리하기 위해서는 **파티션**과 **컨슈머 그룹**의 설정에 주의해야 한다.
- 만일 서버가 다중화 되었다면 다중화된 서버 간 해당 토픽을 처리하는 **컨슈머 그룹은 모두 동일**해야한다.
    - 파티션을 1개로 설정
        - 만약 서버별로 컨슈머 그룹이 다른 경우 다중화된 서버에서 각각 topic을 받아 처리하게 되어 중복 처리 문제 발생
        - 서버별로 컨슈머 그룹이 동일해야, 여러 서버들 중 하나의 서버에서(컨슈머 그룹에 속한 하나의 컨슈머에서)만 처리할 수 있음.
    - 파티션 여러개로 설정
        - 파티션 key 를 잘 설정하여 A → B, B → A 의 요청이 같은 Consumer 에서 처리할 수 있도록 해야 함.
        - 만약 다른 Consumer 에서 처리된다면 똑같이 동시성 문제 발생 가능


또한 위 문제가 아니더라도, 해당 방법을 택하게 되면 DB 이외에 다른 Data Storage 를 사용하는 것이므로, 데이터가 동기화되지 않는 문제가 발생 가능하다.
- 한가지 예시로 Kafka 를 사용한다면
    - (트랜잭션 commit 이후 kafka produce 시) DB 에는 값이 저장되었는데 kafka 로 보내는데 실패한다거나 (network 이슈 등으로),
    - (트랜잭션 commit 전, tx 내부에서 kafka produce 시) kafka 에는 produce 되었으나, DB 는 롤백되어버린다던지 등
    - 이에 대한 고민과 해결방안은 → [[01-2. DB와 카프카 싱크]]

또한 이 외에도 실시간 처리가 안되는 문제도 존재한다.
- (될수도 있음) 그러나 아직 리서치 해보지는 않았음.

아무튼 해당 방법은 단점이 많고 복잡하여 선택하지 않았다.



### 해결방법 후보 2. 낙관적, 비관적 Lock 사용
- 매칭 로직의 2번 과정 (상대방이 나에게 보낸 좋아요 요청 조회) 과정에서 Lock 을 사용하는 방법이다.
- **synchronized**, **자바 자체 Lock** 등은 **scale-out** 시 효과가 없어지므로 대상에서 제외하였다.

#### 비관적락(S-lock, X-lock) 사용 시
- CASE 1.
    - 트랜잭션 : 매칭 로직의 1,2,3 을 모두 한 트랜잭션에서 진행
    - 락 : A가 B 에게 좋아요 요청 시, 2번 과정(B가 A에게 보낸 좋아요 요청 조회)에서 X-Lock (혹은 S-Lock)
    - 문제 발생 시나리오
        - 00:00 `요청 1 - Tx 1`  sender=A, target=B 인 MatchRequest 저장 (저장이므로 X 락 걸림)
        - 00:01 `요청 2 - Tx 1`  sender=B, target=A 인 MatchRequest 저장 (저장이므로 X 락 걸림)
        - 00:02 `요청 1 - Tx 1`  sender=B, target=A 인 MatchRequest 조회 (with 비관적락)
            - → 락 대기 (00:01  에서 sender=B, target=A 인 MatchRequest INSERT 시 X-lock이 걸리기 때문)
        - 00:03 `요청 2 - Tx 1`  sender=A, target=B 인 MatchRequest 조회 (with 비관적락)
            -  → 락 대기 (00:00 에서 sender=A, target=B 인 MatchRequest INSERT 시 X-lock이 걸리기 때문)
    - 즉 **데드락** 발생

- CASE 2
    - 트랜잭션 : 매칭 로직의 1과 2,3 을 **다른 트랜잭션**에서 진행
    - 락 : A가 B 에게 좋아요 요청 시, 2번 과정(B가 A에게 보낸 좋아요 요청 조회)에서 X-Lock (혹은 S-Lock)
    - 문제 발생 시나리오
        - 00:00 `요청 1 - Tx 1`  sender=A, target=B 인 MatchRequest 저장 (**commit**)
        - 00:01 `요청 2 - Tx 1`  sender=B, target=A 인 MatchRequest 저장 (**commit**)
        - 00:02 `요청 1 - Tx 2`  sender=B, target=A 인 MatchRequest 조회 (with 비관적락)
            - → 결과 O
        - 00:03 `요청 2 - Tx 2`  sender=A, target=B 인 MatchRequest 조회 (with 비관적락)
            -  → 결과 O
        - 00:04 `요청 1 - Tx 2`  Match 생성 (A - B) 후 commit
        - 00:05 `요청 2 - Tx 2` Match 생성 (A - B) 후 commit
    - **Match 중복 저장**

즉 A → B 요청 시, B → A 요청만 조회하게 되면 문제가 해결되지 않는다.
이를 해결하기 위해, A → B 요청 시, A → B 요청과 B → A 요청을 모두 lock 을 걸어 조회한다면?
- 00:00 (Tx 1) sender 가 A, target 이 B 인 MatchRequest 저장
- 00:01 (Tx 2) sender 가 B, target 이 A 인 MatchRequest 저장
- 00:02 (Tx 1) sender 가 B, target 이 A 인 MatchRequest 조회 (with 비관적락)
    - → Lock 대기
- 00:03 (Tx 2) sender 가 A, target 이 B 인 MatchRequest 조회 (with 비관적락)
    - → Lock 대기
- → **데드락**! (즉 해결되지 않는다)


#### 낙관적 락 사용 시
- CASE 1.
    - 트랜잭션 : 매칭 로직의 1,2,3 을 모두 한 트랜잭션에서 진행
    - 락 : A가 B 에게 좋아요 요청 시, 2번 과정(B가 A에게 보낸 좋아요 요청 조회)에서 낙관적락
    - 문제 발생 시나리오
        - 00:00 `요청 1 - Tx 1`  sender=A, target=B 인 MatchRequest 저장
        - 00:01 `요청 2 - Tx 1`  sender=B, target=A 인 MatchRequest 저장
        - 00:02 `요청 1 - Tx 1`  sender=B, target=A 인 MatchRequest 조회 (with 낙관적락)
            - → 조회 실패
        - 00:03 `요청 2 - Tx 1`  sender=A, target=B 인 MatchRequest 조회 (with 낙관적락)
            - → 조회 실패
    - **Match 생성 안됨**

- CASE 2
    - 트랜잭션 : 매칭 로직의 1과 2,3 을 **다른 트랜잭션**에서 진행
    - 락 : A가 B 에게 좋아요 요청 시, 2번 과정(B가 A에게 보낸 좋아요 요청 조회)에서 낙관적락
    - 문제 발생 시나리오
        - 00:00 `요청 1 - Tx 1`  sender=A, target=B 인 MatchRequest 저장 (**commit**)
        - 00:01 `요청 2 - Tx 1`  sender=B, target=A 인 MatchRequest 저장 (**commit**)
        - 00:02 `요청 1 - Tx 2`  sender=B, target=A 인 MatchRequest 조회 (with 낙관적락)
            - → 결과 O
        - 00:03 `요청 2 - Tx 2`  sender=A, target=B 인 MatchRequest 조회 (with 낙관적락)
            -  → 결과 O
        - 00:04 `요청 1 - Tx 2`  Match 생성 (A - B) 후 commit
        - 00:05 `요청 2 - Tx 2` Match 생성 (A - B) 후 commit
    - **Match 중복 저장




### 해결방법 후보 3
named lock 혹은 redis lock 사용
- 해결 가능함. 다만 lock 을 걸어줄 이름(name 혹은 key)을 잘 설정해야 함.
- A → B 로의 요청과, B → A 로의 요청에 대해서만 락이 걸려야지, A → B 로의 요청이 있다고 A → C 로의 요청이 막히거나 하면 안됨.
- Key 생성 전략 : A 와 B 의 id 를 오름차순 정렬 후, `낮은 id` + `"-"` + `높은 id`
    - ex: A의 id가 10 이고, B 의 id 가 20일 때,
        - key : "10-20"
    - 이렇게 되어야 문제 없이 동작함.
- 그런데 named lock을 사용한다면, **DB 커넥션을 분리**해줘야 함.
- 만약 그렇지 않고 Tx 내부에서 lock 을 가져오면 **lock 을 릴리즈**하고 **트랜잭션을 커밋**하는 사이에 새로운 요청이 들어올 수 있고, 이로 인해 제대로 동작하지 않을 수 있음.
    - EX 1 - **하나의 트랜잭션** 내에서 매칭 로직의 1,2,3 을 모두 수행하는 경우
        - 00:00 Tx 1 시작
        - 00:01 (Tx 1) lock 획득
        - 00:02 (Tx 1) Match Request 저장
        - 00:03 (Tx 1) 상대 Match Request 조회 -> 없으므로 생략)
        - **00:04 (Tx 1) lock 반환**
            - 00:05 (Tx 2) lock 획득
            - 00:06 (Tx 2) Match Request 저장
            - 00:07 (Tx 2) 상대 Match Request 조회 (Tx1 이 커밋되지 않았으므로 조회되지 않음) -> 없으므로 생략
        - **00:08 (Tx 1) 커밋**
        - 00:09 (Tx 2) lock 반환
        - 00:09 (Tx 2) 커밋
        - → 즉 Match 생성되지 않음
    - (매칭 로직의 1과 2,3을 다른 트랜잭션에서 진행하는 경우에는 name lock 을 쓰더라도 문제 발생함)
        - 00:00 `요청 1 - Tx 1` (A →B) Match Request 저장  (commit)
        - 00:01 `요청 2 - Tx 1` (B →A) Match Request 저장  (commit)
        - 00:02 `요청 1 - Tx 2` 시작
        - 00:03 `요청 1 - Tx 2` lock 획득
        - 00:04 `요청 1 - Tx 2` 상대 Match Request 조회
            - → 있으므로 match 생성
        - **00:05 `요청 1 - Tx 2`  lock 반환**
            - 00:06 `요청 2 - Tx 2` lock 획득
            - 00:07 `요청 2 - Tx 2` 상대 Match Request 조회
                - → 있으므로 match 생성
        - **00:08 `요청 1 - Tx 2` 커밋**
        - 00:09 `요청 2 - Tx 2` lock 반환
        - 00:09 `요청 2 - Tx 2` 커밋
        - → 즉 Match 생성되지 않음


### 실제 해결방법
위 해결방법들을 고민하다 문득 아래  방법이 떠오름
- 매칭 로직의 1과 2,3을 다른 트랜잭션에서 진행한다.
- Match 에 `낮은_id`,  `높은_id` 필드를 두고, 이 둘에 대해 **unique 제약조건**을 건다.

만약  데이터가 중복되었다면 DB 넣을때 터질꺼고, 이를 핸들링 하면 끝이다.

위처럼 간단하게 문제를 해결할 수 있는 방법이 떠올라, 위 방법을 사용하기로 결정.
